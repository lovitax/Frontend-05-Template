学习笔记


## tic-tac-toe 游戏的实现

### 基本思路

1.数据结构：二维数组表示棋盘，棋子通过值表示，0表示未落子，1表示⭕️，2表示❌

2.绘制棋盘，通过数据结构，使用两层for循环绘制即可

3.落子逻辑

4.check逻辑。每个 行/列/斜 与当前user对比，完全一致则胜利。（注意：先落子，再check，再切换用户）

5.willWin逻辑。遍历每一个没有棋子的点，拷贝一个当前的棋盘，然后在这个新的棋盘上落子，检查落子之后是不是赢了

6.完整ai。winter老师说的是三种策略。赢，和，输。
我想自己换种理解方式，是当前局面的问题；
当前局面要是检查出来一步就赢了，那很简单了，直接走赢棋的那步就行
当前局面没有赢棋的，那我就想一下能不能不输，就走一步，然后换成对手，对手也赢不了
当前局面没有赢棋的，那我就想一下能不能不输，就走一步，然后换成对手，对手赢了，那肯定不行（这种情况其实在上一步也会考虑到，所以不需要单独写逻辑）
走情况最好的那步，然后重复

具体落实到代码上，因为每一步考虑的事情都是一样的，所以需要递归实现

递归逻辑：
    1、走一步就赢了，直接走这步就行了，返回当前胜负情况（1）和坐标
    2、遍历所有能走的点，走一步，然后换对手走
    3、对手能赢，自己就输，所以胜负情况取负数


返回值设计：胜负情况，1，0，-1 ；坐标

### 问题

1.样式问题，有棋子和没有棋子的格子对不齐 (vertical-align: middle;)

2.绘制逻辑，落子的时候会重复画新的棋盘

3.check逻辑，只有在win是true的时候才返回，否则会有问题，第一层循环就只走一次就return了

```js
for (let i = 0; i < 3; i++) {
    let win = true;
    for (let j = 0; j < 3; j++) {
        if(pattern[i][j] !== userFlag) {
            win = false;
        }
    }
    if (win) {
        return true;
    }
}
```

4.willWin逻辑其实就是把每一个可能都check一下，这个时候注意不要破坏目前的棋盘，要深拷贝一个棋盘。注意continue的使用，其实else也行？